LITERATURE REVIEW

With the rapidly growing amount of software in use around the world, it has become impossible to manually audit it all for vulnerabilities, so it is imperative that we develop efficient systems to automate this process. Malware and Bots have been a pressing threat to the internet and computational systems. Due to the extensive use of the binary obfuscation, it is very difficult to analyze and classify the bots. Various techniques including intrusion detection uses algorithms that helps to detect and classify these bots and eradicate them. These algorithms must have a good sense of understanding of a bot binary to make accurate classification and filtering. The ability of Machine learning to extract meaningful decision-making based on wide ranging features of data has been applied to wide ranging fields. 
In 2009,  Jian Li et al came up with an algorithm to detect malware obfuscation using maximal patterns which are subsequences in malware's runtime system call sequence, which frequently appear in program execution, and can be used to describe the program specific behavior.  While this approach was resilient to code obfuscation technologies, obfuscation can relocate instructions in a bot binary and also introduce extra system calls into a call sequence. Both of these can negatively affect the classification accuracy. In 2015, Lin et al analyzed a bot binary’s runtime system call trace and use the longest common subsequences between system call traces for the classification of bot binaries. S. Ranjan et al used different machine learning models to identify a botnet in a network based on flow parameters. Network parameters can be changed by bot-herder from time to time and it will take some time for this algorithm to figure out and get adjusted. If this process repeats, the learning may have to be discarded altogether each time and it becomes a huge overhead for the classifying system. In 2011, Konrad and others proposed a framework for automatically identifying novel classes of malware with similar behavior (clustering) and assigning unknown malware to these discovered classes (classification) that reduced the run-time overhead of current analysis methods, while providing accurate discovery and discrimination of novel malware variants. However, the framework focuses on a single environment to classify the malware binaries. It does not provide any results for the type of behavior of malware in different conditions. L Natraj et al visualized Malware binaries as gray-scale images  with k-nearest neighbors approach with the observation that for many malware families, the images belonging to the same family appear very similar in layout and texture.Adversaries can relocate sections in a binary or adding vast amount of redundant data as countermeasures to the method. In 2015, Lin et al proposed a 3-phase behaviour based malware detection and classification approach to detect and classify an unknown malware. David and others came up with a publicly available infrastructure for performing program verification and analysis tasks on binary/executable code. 
The most common Malware datasets that include raw program files used for researching on automated analysis and classification of Malware are- the Genome Project [1], Virus Share[2], Virus Total [3], Drebin[4] and Microsoft [4]. The Virus Share and VirusTotal datasets continuously update their repository of malware files, providing an ever-evolving list of new types of malware. The Comodo dataset is another large dataset containing 22,500 malicious and 22,500 benign raw files. The Genome Project dataset consists of 2123 applications, of which 1260 are malicious spanning 49 different malware families collected between August 2010 to October 2011. The Microsoft dataset was built for a kaggle competition and contains 10,868 labeled malware binary files in hexadecimal and assembly representation from nine different malware families: RAmnit, Lollipop, Kelihos_ver3, Vundo, Simda, Tracur, Kelihos_ver1, Obfuscator, ACY, and Gatak.  Efforts to categorise malware based on these datasets extract features from raw program files through static and dynamic analysis and some features from binary versions of the software. 

There are several tools for static analysis of executables. “BAP: A Binary Analysis Platform” [11] is a publicly available infrastructure for performing program verification and analysis tasks on binary/executable code. BAP is divided into front-end and back-end components that are connected by the BAP intermediate language (IL). The front end is responsible for lifting binary code for the supported architectures to the IL. The back-end implements program analyses and verifications for low-level code. A number of analyses, optimizations, and verification techniques are already built into BAP, and adding new ones is easy. Some analyses require indirect jumps to be resolved to concrete locations. For instance, it is not possible to generate VCs using weakest preconditions in the presence of unresolved indirect jumps, since weakest precondition is a static analysis.

The work “Automatic Analysis and Classification of Obfuscated Bot Binaries” [12] analyzes a bot binary’s runtime system call trace and uses the longest common subsequences between system call traces for the classification of bot binaries. The types of Malware analysed were 564 real-world bot binaries eg. Agobot, Bodombot, Devbot from the honeypot at the campus of National Chiao Tung University, along with 4 programs: notepad, Firefox, MS Word, and 7-Zip. For each of the 564 binaries, 3 obfuscated variants were created with ASProtect, Themida, and UPX respectively. This resulted in a total of 2256 binaries. The framework uses dynamic analysis to extract the system call sequence of a bot binary. Since system calls define the interactions between a program (the bot binary) and the operating system, obfuscation can hardly alter the call sequence without breaking the interactions. The paper relies on this property and uses the system call sequence to characterize the behavior of a bot binary. The framework then classifies the binaries based on the LCS similarity and gap shift ratios of system call sequences. The experiment achieves high classification accuracy (94% true positive rate and 93% true negative rate) even with obfuscated bot binaries. Although obfuscation can hardly change the original system call sequence in a bot binary, it can often introduce additional system calls into an obfuscated binary. The additional system calls are noises to the classification process and should have been dealt with.

Deep Learning has been used in static and behavioral based malware detection due to its capability of detecting zero-day malware. In the work - “Droid-Sec: Deep Learning in Android Malware Detection” [7], the authors developed DL-based detectors of malicious Android applications using features from static and dynamic analyses, with the second study improving on the first. The features were drawn from static analysis of required permissions and sensitive application program interfaces (APIs), and dynamic behaviors. The static-based features are derived from the manifest and installation file. The dynamic behavior features are derived from dynamic analysis by collecting data from DroidBox, an Android application sandbox. The algorithm used for modelling the classifier was Deep Belief Network . It is hierarchically built by stacking a number of restricted Boltzmann machines (RBM) with regarding the deep neural network as a latent variable model. These features were the input to a DBN with two hidden layers that achieved a 96.76% accuracy The authors concluded that dynamic features tend to be more reliable than static features, which can be easily obfuscated. Therefore, it is common to use features such as API calls, derived from running the software in a sandbox.

The paper “Malware Images: Visualization and Automatic Classification” [13] visualizes malware binaries as gray-scale images, with the observation that for many malware families, the images belonging to the same family appear very similar in layout and texture. k-nearest neighbors with Euclidean distance is used for classification of images.The dataset used was by Anubis (short for Analyzing Unknown Binaries) and had 25 Families of malware. The usage of computer vision for malware classification is a novel approach that retrieved encouraging results. However, adversaries can relocate sections in a binary or add vast amounts of redundant data as countermeasures to the method.

In the work - ‘Deep neural network based malware detection using two dimensional binary program features’ [6], the authors Joshua Saxe and Konstantin Berlin conducted a study on more than 400,000 software binaries sourced directly from Invincea customers and internal malware databases. Their approach can be broken down into three components. The first component extracts four different types of complementary features from the static benign and malicious binaries. The second component is our deep neural network classifier which consists of an input layer, two hidden layers and an output layer. The final component is our score calibrator, which translates the outputs of the neural network to a score that can be realistically interpreted as approximating the probability that the file is actually malware. This work used a Bayesian calibration model to provide a probability that a given file is malware. This is based on a prior of the ratio of malware to benignware and the DNN’s error rate, using an Epanechnikov kernel for kernel density estimation. They claim to achieve a level of success that could be implemented in real life: a 95% detection rate. 
Kolosnjaji et al. [8] used CNNs and RNNs to identify malware. The dataset was created by the authors  using existing malware samples from Virus Share, Maltrieve and private collections and traced malware behavior using a malware zoo and Cuckoo sandbox for dynamic analysis. Calls to the kernel API were recording during their execution. The list of call sequences to the API kernel is converted into binary vectors using one-hot encoding. One-hot encoding is a scheme for storing categorical data in form easier for machine learning. This data is used to train the DL algorithm, which consists of a CNN and RNN (consisting of an LSTM, and a softmax layer). This model achieves an accuracy of 89.4%, precision of 85.6%, and recall of 89.4%.
Recent studies generated adversarial malware samples to evade Deep Learning based malware detection.Xu et al. [10] evaded two PDF malware classifier, PDFrate and Hidost, by modifying PDF and parsed the PDF file and changed its object structure using genetic programming. The adversarial PDF file was then packed with new objects. Another study that showcases the generation and effect of adversarial examples in malware detection is - ‘Adversarial examples for malware detection’ (2017). The authors identify and overcome key challenges that prevent existing algorithms from being applied against malware detection. The authors guarantees the malware functionality of the adversarially manipulated program using their technique by training a neural network for malware detection on the DREBIN data set and achieve classification performance matching state-of-the-art from the literature. Using the augmented adversarial crafting algorithm they manage to mislead this classifier for 63% of all malware samples.

 
References : 
1. Zhou, Yajin, and Xuxian Jiang. "Dissecting android malware: Characterization and evolution." 2012 IEEE symposium on security and privacy. IEEE, 2012.
2. VirusShare. Available online: http://virusshare.com/ 
3. VirusTotal. Available online: https://virustotal.com
4. Arp, D.; Spreitzenbarth, M.; Hubner, M.; Gascon, H.; Rieck, K.; Siemens, C.E.R.T. DREBIN: Effective and Explainable Detection of Android Malware in Your Pocket. NDSS 2014, 14, 23–26.
5. Microsoft Malware Classification (2015) - https://www.kaggle.com/c/malwareclassification/data
6. Saxe, Joshua, and Konstantin Berlin. "Deep neural network based malware detection using two dimensional binary program features." 2015 10th International Conference on Malicious and Unwanted Software (MALWARE). IEEE, 2015.
7. Yuan, Zhenlong, et al. "Droid-sec: deep learning in android malware detection." ACM SIGCOMM Computer Communication Review. Vol. 44. No. 4. ACM, 2014.
8. Kolosnjaji, Bojan, et al. "Deep learning for classification of malware system call sequences." Australasian Joint Conference on Artificial Intelligence. Springer, Cham, 2016.
9. Grosse, Kathrin, et al. "Adversarial examples for malware detection." European Symposium on Research in Computer Security. Springer, Cham, 2017.
10. W. Xu, Y. Qi, and D. Evans, “Automatically evading classifiers,” in Proc. Netw. Distrib. Syst. Secur. Symp. (NDSS), 2016, pp. 1–15.
11. Brumley D., Jager I., Avgerinos T., Schwartz E.J. (2011) “BAP: A Binary Analysis Platform.” In: Gopalakrishnan G., Qadeer S. (eds) Computer Aided Verification. CAV 2011. Lecture Notes in Computer Science, vol 6806. Springer, Berlin, Heidelberg
12. Lin, Y.-D & Chiang, Y.-T & Wu, Y.-S & Lai, Y.-C. “Automatic analysis and classification of obfuscated bot binaries.”  2014.
13. Nataraj, L., Karthikeyan, S., Jacob, G., and Manjunath, B. S. “Malware Images: Visualization and Automatic Classification.” In Proceedings of the 8th International Symposium on Visualization for Cyber Security. New York, NY, USA: ACM. https://doi.org/10.1145/2016904.2016908, (2011).
14. “Automatic Analysis of Malware Behavior using Machine Learning”. Konrad Rieck, Philipp Trinius, Carsten Willems, Thorsten Holz,Berlin Institute of Technology, Germany, University of Mannheim, Germany,Vienna University of Technology, Austria.
15. “Three-phase behavior-based detection and classification of known and unknown malware”. Ying-Dar Lin, Department of Computer Science, National Chiao Tung University, Hsinchu 300, Taiwan, Yuan-Cheng Lai, Department of Information Management, National Taiwan University of Science and Technology, Taipei 106, Taiwan, Chun-Nan Lu, Peng-Kai Hsu and Chia-Yin Lee, Information & Communication Technology Laboratories, National Chiao Tung University, Hsinchu 300, Taiwan
